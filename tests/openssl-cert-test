#! /bin/bash

set -eu

cd "$(dirname "$0")"

rm -f tmp.*

function die () {
    echo "$@" >&2
    exit 1
}

openssl genpkey -algorithm ed25519 -out tmp.root.key
openssl pkey -in tmp.root.key -pubout -out tmp.root.key.pub

openssl genpkey -algorithm ed25519 -out tmp.sign.key
openssl pkey -in tmp.sign.key -pubout -out tmp.sign.key.pub

# It's not clear what expectations to verify on generated certs.
# Currently, we check key usage bits (which aren't that important). It
# would be reasonable to check that the resulting cert chain is valid,
# e.g, using
#
#  openssl verify -trusted tmp.root.cert tmp.sign.cert
#
# But that fails, because x509 chaining is based on subject and issuer
# names, and stmgr leaves those fields empty, violating
# https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.4

# Create a CA root cert
go run ../stmgr.go keygen certificate -isCA -rootKey tmp.root.key -certOut tmp.root.cert

openssl x509 -text <tmp.root.cert | grep CA:TRUE >/dev/null || die "Not a CA cert"
openssl x509 -text <tmp.root.cert | grep " *Digital Signature, Certificate Sign$" >/dev/null || die "Unexpected CA cert usage"

# Create a signing cert, signed with the CA's private key.
go run ../stmgr.go keygen certificate -rootCert tmp.root.cert -rootKey tmp.root.key \
   -subjectKey tmp.sign.key.pub -certOut tmp.sign.cert

if openssl x509 -text <tmp.sign.cert | grep CA:TRUE >/dev/null ; then die "Unexpected CA cert" ; fi
openssl x509 -text <tmp.sign.cert | grep " *Digital Signature$" >/dev/null || die "Unexpected signing cert usage"
